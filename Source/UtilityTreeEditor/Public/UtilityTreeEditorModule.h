// Copyright 2015-2017 Piperift. All Rights Reserved.
#pragma once

#include "UnrealEd.h"

#include "KismetCompilerModule.h"
#include "Runtime/Launch/Resources/Version.h"
#include "PropertyEditorModule.h"
#include "IAssetTools.h"
#include "UtilityTree/IUtilityTreeEditor.h"
#include "UtilityTree/UTBlueprintCompiler.h"

#include "UtilityTreeBlueprint.h"
 

DECLARE_LOG_CATEGORY_EXTERN(LogUtilityEd, All, All)
 
class FUtilityTreeEditorModule : public IModuleInterface, public IBlueprintCompiler
{
public:

	FUtilityTreeEditorModule()
	{}

    virtual void StartupModule() override;
    virtual void ShutdownModule() override;

    // Get Quest Extension Editor module instance
    FORCEINLINE static FUtilityTreeEditorModule& GetInstance() {
        return FModuleManager::LoadModuleChecked<FUtilityTreeEditorModule>("UtilityTreeEditor");
    }

private:

    void RegisterPropertyTypeCustomizations();
    void PrepareAutoGeneratedDefaultEvents();
    void RegisterComponentVisualizer(FName ComponentClassName, TSharedPtr<FComponentVisualizer> Visualizer);

    /**
    * Registers a custom struct
    *
    * @param StructName                The name of the struct to register for property customization
    * @param StructLayoutDelegate    The delegate to call to get the custom detail layout instance
    */
    void RegisterCustomPropertyTypeLayout(FName PropertyTypeName, FOnGetPropertyTypeCustomizationInstance PropertyTypeLayoutDelegate);

    template<class T>
    void RegisterCustomPinFactory();

	void RegisterAssetTypeAction(IAssetTools& AssetTools, TSharedRef<IAssetTypeActions> Action)
	{
		AssetTools.RegisterAssetTypeActions(Action);
		CreatedAssetTypeActions.Add(Action);
	}

    //Simplify Registering generated default events
#define RegisterDefaultEvent(Class, FuncName) \
    (FKismetEditorUtilities::RegisterAutoGeneratedDefaultEvent(this, Class::StaticClass(), GET_FUNCTION_NAME_CHECKED(Class, FuncName)))

	/** All created asset type actions.  Cached here so that we can unregister them during shutdown. */
	TArray< TSharedPtr<IAssetTypeActions> > CreatedAssetTypeActions;



	//~ Begin BlueprintCompiler Interface
	virtual bool CanCompile(const UBlueprint* Blueprint) override
	{
		return Cast<UUtilityTreeBlueprint>(Blueprint) != nullptr;
	}

	virtual void Compile(UBlueprint* Blueprint, const FKismetCompilerOptions& CompileOptions, FCompilerResultsLog& Results, TArray<UObject*>* ObjLoaded) override
	{
		if (UUtilityTreeBlueprint* WidgetBlueprint = CastChecked<UUtilityTreeBlueprint>(Blueprint))
		{
			FUTBlueprintCompiler Compiler(WidgetBlueprint, Results, CompileOptions, ObjLoaded);
			Compiler.Compile();
			check(Compiler.NewClass);
		}
	}

	virtual bool GetBlueprintTypesForClass(UClass* ParentClass, UClass*& OutBlueprintClass, UClass*& OutBlueprintGeneratedClass) const override
	{
		if (ParentClass == UUtilityTree::StaticClass() || ParentClass->IsChildOf(UUtilityTree::StaticClass()))
		{
			OutBlueprintClass = UUtilityTreeBlueprint::StaticClass();
			OutBlueprintGeneratedClass = UUTBlueprintGeneratedClass::StaticClass();
			return true;
		}

		return false;
	}
	//~ End BlueprintCompiler Interface

};